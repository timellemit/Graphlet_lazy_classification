#include "os_gl.h"
#ifdef __cplusplus
extern "C" {
#endif
#if defined(PURE_OPENGL_ES_2)
#elif defined(OPENGL_ES_2)
/* these are the shaders that uses ES2 */
const char* default_vs =
"attribute vec4 a_Vertex;\n"
"attribute vec3 a_Normal;\n"
"attribute vec4 a_Color;\n"
"attribute float a_Accessibility; /* This is for ambient occlusion, 1.0 by default */\n"
"varying vec3 packed_data_0 ;\n"
"varying vec4 packed_data_1 ;\n"
"varying vec4 packed_data_2 ;\n"
"varying vec4 packed_data_3 ;\n"
"varying vec4 packed_data_4 ;\n"
"//varying vec3 N;\n"
"#define NORMAL  packed_data_0\n"
"#define COLOR packed_data_3\n"
"//#define fog packed_data_1.w\n"
"#define E 2.718281828459045\n"
"/* this doesn't work for setting fog_color, need to set the values independently */\n"
"//#define fog_color ( packed_data_1.x, packed_data_1.y, packed_data_1.z )\n"
"varying float fog;\n"
"varying vec2 bgTextureLookup;\n"
"uniform vec2 t2PixelSize;\n"
"uniform bool lighting_enabled;\n"
"uniform bool bg_gradient;\n"
"uniform float ambient_occlusion_scale;\n"
"uniform int accessibility_mode;\n"
"uniform float accessibility_mode_on;\n"
"void main()\n"
"{\n"
"  NORMAL = normalize(gl_NormalMatrix * a_Normal);\n"
"  vec3 eye_pos = vec3(gl_ModelViewMatrix * a_Vertex);\n"
"  vec4 COLORa;\n"
"  if (accessibility_mode == 1){\n"
"    COLORa = vec4(clamp(a_Color.xyz * (1.-(ambient_occlusion_scale*a_Accessibility)), 0., 1.), a_Color.w);\n"
"  } else if (accessibility_mode == 2){\n"
"    COLORa = vec4(a_Color.xyz * cos(90.*radians(clamp(ambient_occlusion_scale*a_Accessibility, 0., 1.))), a_Color.w);\n"
"  } else {\n"
"    COLORa = vec4(clamp(a_Color.xyz * (1. / (1. + pow(E, 0.5 * ( (ambient_occlusion_scale * a_Accessibility) - 10.)))), 0., 1.), a_Color.w);\n"
"  }\n"
"  COLOR = mix(a_Color, COLORa, accessibility_mode_on);\n"
"  // This was breaking fog on ATI/Linux\n"
"  //  gl_FogFragCoord = -eye_pos.z;\n"
"  //  fog = (gl_Fog.end - gl_FogFragCoord) * gl_Fog.scale;\n"
"  fog = (gl_Fog.end - abs(eye_pos.z)) * gl_Fog.scale;\n"
"  gl_Position = gl_ModelViewProjectionMatrix * a_Vertex;\n"
"  bgTextureLookup = (gl_Position.xy/gl_Position.w) / 2.0 + 0.5;\n"
"}\n"
;
const char* default_fs =
"varying vec3 packed_data_0 ;\n"
"varying vec4 packed_data_1 ;\n"
"varying vec4 packed_data_2 ;\n"
"varying vec4 packed_data_3 ;\n"
"varying vec4 packed_data_4 ;\n"
"//varying vec3 N;\n"
"#define COLOR packed_data_3\n"
"#define NORMAL normalize(packed_data_0.xyz)\n"
"uniform float fog_enabled;\n"
"varying float fog;\n"
"uniform sampler2D bgTextureMap;\n"
"uniform vec3 fogSolidColor;\n"
"uniform float fogIsSolidColor;\n"
"varying vec2 bgTextureLookup;\n"
"uniform bool lighting_enabled;\n"
"uniform bool two_sided_lighting_enabled;\n"
"uniform int light_count;\n"
"uniform vec4 interior_color;\n"
"uniform float interior_color_threshold;\n"
"uniform float shininess;\n"
"uniform float shininess_0;\n"
"uniform bool use_interior_color_threshold;\n"
"uniform int spec_count;\n"
"uniform float spec_value;\n"
"uniform float spec_value_0;\n"
"#include ANAGLYPH_HEADER\n"
"uniform float isStretched;\n"
"uniform float isCentered;\n"
"uniform float isCenteredOrRepeated;\n"
"uniform float isTiled;\n"
"uniform vec2 tileSize;\n"
"uniform vec2 tiledSize;\n"
"uniform vec2 viewImageSize;\n"
"uniform vec2 pixelSize;\n"
"uniform vec2 halfPixel;\n"
"#include ComputeFogColor\n"
"#include ComputeColorForLight\n"
"void main()\n"
"{\n"
"  vec4 final_color = vec4(0.);\n"
"  if (lighting_enabled){\n"
"    bool is_interior = false;\n"
"    if (use_interior_color_threshold || two_sided_lighting_enabled){\n"
"      vec3 viewV = vec3(0.,0.,-1.);\n"
"      float dotp = dot(NORMAL, viewV);\n"
"      is_interior = ( dotp > interior_color_threshold );\n"
"    }\n"
"    if (!two_sided_lighting_enabled && is_interior){\n"
"      final_color = interior_color;\n"
"    } else {\n"
"      final_color = (gl_LightModel.ambient) * COLOR;\n"
"#include CallComputeColorForLight\n"
"    }\n"
"  } else {\n"
"    final_color = COLOR;\n"
"  }\n"
"  float cfog = mix(1.0, clamp(fog, 0.0, 1.0), fog_enabled);\n"
"  vec4 fogColor = ComputeFogColor();\n"
"  vec4 fColor = vec4(mix(vec3(fogColor), final_color.rgb, cfog), COLOR.a);\n"
"#include ANAGLYPH_BODY\n"
"}\n"
;
#else
/* these are the original default shaders */
const char* default_vs =
"varying vec3 N, L0, H0, L1, H1;\n"
"varying vec4 D0, A0, D1, A1;\n"
"varying float fog;\n"
"varying vec3 fog_color;\n"
"uniform bool lighting_enabled;\n"
"uniform bool bg_gradient;\n"
"uniform vec3 fog_color_top;\n"
"uniform vec3 fog_color_bottom;\n"
"void main()\n"
"{\n"
"  N = normalize(gl_NormalMatrix * gl_Normal);\n"
"  vec3 eye_pos = vec3(gl_ModelViewMatrix * gl_Vertex);\n"
"  vec3 aux = vec3(gl_LightSource[0].position - vec4(eye_pos, 1.0));\n"
"  if (lighting_enabled){\n"
"    L0 = normalize(aux);\n"
"    H0 = normalize(gl_LightSource[0].halfVector.xyz);\n"
"    aux = vec3(gl_LightSource[1].position - vec4(eye_pos, 1.0));\n"
"    L1 = normalize(aux);\n"
"    H1 = normalize(gl_LightSource[1].halfVector.xyz);\n"
"    A0 = gl_LightSource[0].ambient * gl_Color;\n"
"    D0 = gl_LightSource[0].diffuse * gl_Color;\n"
"    A1 = gl_LightSource[1].ambient * gl_Color;\n"
"    D1 = gl_LightSource[1].diffuse * gl_Color;\n"
"    A0.a = gl_Color.a;\n"
"    A1.a = 0.;\n"
"  } else {\n"
"    A0 = gl_Color;\n"
"  }\n"
"  gl_FogFragCoord = -eye_pos.z;\n"
"  fog = (gl_Fog.end - gl_FogFragCoord) * gl_Fog.scale;\n"
"  gl_Position = gl_ModelViewProjectionMatrix * a_Vertex;\n"
"  if (bg_gradient){\n"
"    fog_color = mix(fog_color_bottom, fog_color_top, (1. + gl_Position.y/gl_Position.w)/2.);\n"
"  } else {\n"
"    fog_color = fog_color_top;\n"
"  }\n"
"  gl_Position = ftransform();\n"
"}\n"
;
const char* default_fs =
"varying vec3 N, L0, H0, L1, H1;\n"
"varying vec4 D0, A0, D1, A1;\n"
"uniform float fog_r;\n"
"uniform float fog_g;\n"
"uniform float fog_b;\n"
"uniform float fog_enabled;\n"
"uniform bool lighting_enabled;\n"
"varying float fog;\n"
"void main()\n"
"{\n"
"  vec3 n, h;\n"
"  float NdotL, NdotH;\n"
"  vec4 color;\n"
"  n = normalize(N);\n"
"  NdotL = max(dot(n, normalize(L0)), 0.0);\n"
"  float shininess = gl_FrontMaterial.shininess;\n"
"  color = A0;\n"
"  if (lighting_enabled){\n"
"    color = A0 + A1;\n"
"    if (NdotL > 0.0) {\n"
"      color += D0 * NdotL;\n"
"      h = normalize(H0);\n"
"      NdotH = max(dot(n, h), 0.0);\n"
"      color += gl_LightSource[0].specular * pow(NdotH, shininess);\n"
"    }\n"
"    NdotL = max(dot(n, normalize(L1)), 0.0);\n"
"    if (NdotL > 0.0) {\n"
"      color += D1 * NdotL;\n"
"      h = normalize(H1);\n"
"      NdotH = max(dot(n, h), 0.0);\n"
"      color += gl_LightSource[1].specular * pow(NdotH, shininess);\n"
"    }\n"
"  }\n"
"  float cfog = mix(1.0, clamp(fog, 0.0, 1.0), fog_enabled);\n"
"  gl_FragColor = vec4(mix(color.rgb, fog_color, cfog), A0.a);\n"
"}\n"
;
#endif
const char* volume_vs =
"varying float fog;\n"
"uniform float g_Fog_end;\n"
"uniform float g_Fog_scale;\n"
"varying vec2 bgTextureLookup;\n"
"void main()\n"
"{\n"
"  vec4 vertex = gl_ModelViewMatrix * gl_Vertex;\n"
"  gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"  gl_ClipVertex = vertex;\n"
"  gl_Position = ftransform();\n"
"  gl_FogFragCoord = -vertex.z;\n"
"  fog = (g_Fog_end - gl_FogFragCoord) * g_Fog_scale;\n"
"  bgTextureLookup = (gl_Position.xy/gl_Position.w) / 2.0 + 0.5;\n"
"}\n"
;
const char* volume_fs =
"uniform sampler3D volumeTex;\n"
"uniform sampler1D colorTex;\n"
"uniform float volumeScale;\n"
"uniform float volumeBias;\n"
"uniform sampler3D carvemask;\n"
"uniform bool carvemaskFlag;\n"
"uniform float fog_enabled;\n"
"uniform sampler2D bgTextureMap;\n"
"uniform vec3 fogSolidColor;\n"
"uniform float fogIsSolidColor;\n"
"varying float fog;\n"
"uniform float g_Fog_end;\n"
"uniform float g_Fog_scale;\n"
"varying vec2 bgTextureLookup;\n"
"uniform float isStretched;\n"
"uniform float isCentered;\n"
"uniform float isCenteredOrRepeated;\n"
"uniform float isTiled;\n"
"uniform vec2 tileSize;\n"
"uniform vec2 tiledSize;\n"
"uniform vec2 viewImageSize;\n"
"uniform vec2 pixelSize;\n"
"uniform vec2 halfPixel;\n"
"#include ComputeFogColor\n"
"bool iscarvemasked(vec3 t) {\n"
"  return carvemaskFlag && texture3D(carvemask, t).r > 0.5;\n"
"}\n"
"void main()\n"
"{\n"
"  if (iscarvemasked(gl_TexCoord[0].xyz))\n"
"    discard;\n"
"  float v = texture3D(volumeTex, gl_TexCoord[0].xyz).r;\n"
"  v = v * volumeScale + volumeBias;\n"
"  if (v < 0. || v > 1.) discard;\n"
"  vec4 color = texture1D(colorTex, v);\n"
"  if (color.a == 0.0) discard;\n"
"  float cfog = mix(1.0, clamp(fog, 0.0, 1.0), fog_enabled);\n"
"  vec4 fogColor = ComputeFogColor();\n"
"  gl_FragColor = vec4(vec3(mix(fogColor.rgb, color.rgb, cfog)), color.a);\n"
"}\n"
;
const char* sphere_vs =
"// Sphere impostor vertex shader\n"
"uniform bool lighting_enabled;\n"
"uniform float sphere_size_scale;\n"
"uniform float horizontal_adjustment;\n"
"uniform float vertical_adjustment;\n"
"attribute vec4 a_vertex_radius;\n"
"attribute vec4 a_Color;\n"
"attribute float a_rightUpFlags;\n"
"varying vec4 COLOR;\n"
"varying vec3 sphere_center;\n"
"varying float radius2;\n"
"varying vec3 point;\n"
"varying vec2 bgTextureLookup;\n"
"void main(void)\n"
"{\n"
"    // Get billboard attributes\n"
"    float radius = a_vertex_radius.w * sphere_size_scale;\n"
"    float right = -1. + 2.*mod(a_rightUpFlags, 2.);\n"
"    float up = -1. + 2.*floor(mod(a_rightUpFlags/2., 2.));\n"
"    vec4 a_Vertex = vec4(a_vertex_radius.xyz, 1.);\n"
"    COLOR = a_Color;\n"
"    radius2 = radius * radius; // compute squared radius \n"
"    vec3 right_vector = vec3(gl_ModelViewMatrix[0][0],\n"
"            gl_ModelViewMatrix[1][0], gl_ModelViewMatrix[2][0]);\n"
"    vec3 up_vector = vec3(gl_ModelViewMatrix[0][1],\n"
"            gl_ModelViewMatrix[1][1], gl_ModelViewMatrix[2][1]);\n"
"    // We need to project the vertex out to the edge of the square, which\n"
"    // is the following distance:\n"
"    // float corner_distance = sqrt(2.0 * radius2);\n"
"    // but since we need to normalize the corner vector computed below\n"
"    // which has length sqrt(2.0), we can simply use radius as corner distance\n"
"    // to compute vertex position of screen-oriented quad.\n"
"    // Compute corner vector\n"
"    vec3 corner_direction =  (vertical_adjustment*up) * up_vector + (horizontal_adjustment*right) * right_vector;\n"
"    // Calculate vertex of screen-oriented quad (billboard)\n"
"    vec4 vertex = vec4(a_Vertex.xyz + radius * corner_direction, 1.);\n"
"    // Calculate vertex position in modelview space\n"
"    vec4 eye_space_pos = gl_ModelViewMatrix * vertex;\n"
"    // Compute sphere position in modelview space\n"
"    vec4 tmppos = gl_ModelViewMatrix * a_Vertex;\n"
"    sphere_center = tmppos.xyz / tmppos.w;\n"
"    // Compute ray direction and origin point\n"
"    point = eye_space_pos.xyz / eye_space_pos.w;\n"
"    // Pass the transformed vertex for clipping plane calculations\n"
"    gl_ClipVertex = eye_space_pos;\n"
"    // Pass transformed vertex\n"
"    gl_Position = gl_ModelViewProjectionMatrix * vertex;\n"
"    bgTextureLookup = (gl_Position.xy/gl_Position.w) / 2.0 + 0.5;\n"
"}\n"
;
const char* sphere_fs =
"// Sphere impostor fragment shader\n"
"uniform bool lighting_enabled;\n"
"uniform float ortho;\n"
"uniform float fog_enabled;\n"
"uniform sampler2D bgTextureMap;\n"
"uniform vec3 fogSolidColor;\n"
"uniform float fogIsSolidColor;\n"
"uniform bool bg_gradient;\n"
"uniform float inv_height;\n"
"uniform int light_count;\n"
"uniform float shininess;\n"
"uniform float shininess_0;\n"
"uniform int spec_count;\n"
"uniform float spec_value;\n"
"uniform float spec_value_0;\n"
"#include ANAGLYPH_HEADER\n"
"varying vec4 COLOR;\n"
"varying vec3 sphere_center;\n"
"varying float radius2;\n"
"varying vec3 point;\n"
"uniform float g_Fog_end;\n"
"uniform float g_Fog_scale;\n"
"varying vec2 bgTextureLookup;\n"
"uniform float isStretched;\n"
"uniform float isCentered;\n"
"uniform float isCenteredOrRepeated;\n"
"uniform float isTiled;\n"
"uniform vec2 tileSize;\n"
"uniform vec2 tiledSize;\n"
"uniform vec2 viewImageSize;\n"
"uniform vec2 pixelSize;\n"
"uniform vec2 halfPixel;\n"
"#include ComputeFogColor\n"
"#include ComputeColorForLight\n"
"void main(void)\n"
"{\n"
"    vec3 ray_origin = mix(vec3(0.,0.,0.), point, ortho);\n"
"    vec3 ray_direction = mix(normalize(point), vec3(0., 0., 1.), ortho);\n"
"    vec3 sphere_direction = mix(sphere_center, ray_origin - sphere_center, ortho);\n"
"    // Calculate sphere-ray intersection\n"
"    float b = dot(sphere_direction, ray_direction);\n"
"    float position = b * b + radius2 - dot(sphere_direction, sphere_direction);\n"
"    // Check if the ray missed the sphere\n"
"    if (position < 0.0)\n"
"       discard;\n"
"    // Calculate nearest point of intersection\n"
"    float nearest = mix(b - sqrt(position), sqrt(position) - b, ortho);\n"
"    // Calculate intersection point on the sphere surface.  The ray\n"
"    // origin is at the quad (center point), so we need to project\n"
"    // back towards the user to get the front face.\n"
"    vec3 ipoint = nearest * ray_direction + ray_origin;\n"
"    // Calculate normal at the intersection point\n"
"    vec3 N = normalize(ipoint - sphere_center);\n"
"    // Calculate depth in clipping space \n"
"    vec2 clipZW = ipoint.z * gl_ProjectionMatrix[2].zw +\n"
"        gl_ProjectionMatrix[3].zw;\n"
"    float depth = 0.5 + 0.5 * clipZW.x / clipZW.y;\n"
"    // this is a workaround necessary for Mac\n"
"    // otherwise the modified fragment won't clip properly\n"
"/*\n"
"    float isDiscarded = step(.5, step(depth, 0.) + step(1.-depth, 0.));\n"
"    if (isDiscarded > 0.0)\n"
"      discard;\n"
"*/\n"
"    if (depth <= 0.0)\n"
"      discard;\n"
"    if (depth >= 1.0)\n"
"      discard;\n"
"    gl_FragDepth = depth;\n"
"    vec4 color;\n"
"    vec3 L0 = normalize(vec3(gl_LightSource[0].position) - ipoint);\n"
"    float NdotL = max(dot(N, L0), 0.0);\n"
"    float NdotH;\n"
"    vec4 final_color = (gl_LightModel.ambient) * COLOR;\n"
"#include CallComputeColorForLight\n"
"/*\n"
"    int i;\n"
"    for (i=0; i<light_count;i++){\n"
"      vec3 L = normalize(gl_LightSource[i].position.xyz);\n"
"      vec3 H = normalize(gl_LightSource[i].halfVector.xyz);\n"
"      float spec = 0., shine = 0.;\n"
"      if (i==0){\n"
"        spec = spec_value_0;\n"
"        shine = shininess_0;\n"
"      } else if (spec_count >= i){\n"
"        spec = spec_value;\n"
"        shine = shininess;\n"
"      }\n"
"      final_color += gl_LightSource[i].ambient * COLOR;\n"
"      NdotL = dot(N, L);\n"
"      if (NdotL > 0.0) {\n"
"        final_color += gl_LightSource[i].diffuse * NdotL * COLOR;\n"
"        NdotH = max(dot(N, H), 0.0);\n"
"        final_color += spec * pow(NdotH, shine);\n"
"      }\n"
"    }\n"
"*/\n"
"    float fogv = (g_Fog_end + ipoint.z) * g_Fog_scale;\n"
"    float cfog = clamp(fogv, 0.0, 1.0);\n"
"    cfog = mix(1.0, clamp(cfog, 0.0, 1.0), fog_enabled);\n"
"    vec4 fogColor = ComputeFogColor();\n"
"    final_color.rgb = mix(fogColor.rgb, final_color.rgb, cfog);\n"
"    vec4 fColor = vec4(final_color.rgb, COLOR.a);\n"
"#include ANAGLYPH_BODY\n"
"}\n"
;
const char* spheredirect_vs =
"// Sphere impostor vertex shader\n"
"uniform bool lighting_enabled;\n"
"uniform float sphere_size_scale;\n"
"attribute vec4 sphere_attributes;\n"
"varying vec4 COLOR;\n"
"varying vec3 sphere_center;\n"
"varying float radius2;\n"
"varying vec3 point;\n"
"varying vec2 bgTextureLookup;\n"
"void main(void)\n"
"{\n"
"    // Get billboard attributes\n"
"    float right = sphere_attributes.x;\n"
"    float up = sphere_attributes.y;\n"
"    float radius = sphere_attributes.z * sphere_size_scale;\n"
"    COLOR = gl_Color;\n"
"    radius2 = radius * radius; // compute squared radius \n"
"    vec3 right_vector = vec3(gl_ModelViewMatrix[0][0],\n"
"            gl_ModelViewMatrix[1][0], gl_ModelViewMatrix[2][0]);\n"
"    vec3 up_vector = vec3(gl_ModelViewMatrix[0][1],\n"
"            gl_ModelViewMatrix[1][1], gl_ModelViewMatrix[2][1]);\n"
"    // We need to project the vertex out to the edge of the square, which\n"
"    // is the following distance:\n"
"    // float corner_distance = sqrt(2.0 * radius2);\n"
"    // but since we need to normalize the corner vector computed below\n"
"    // which has length sqrt(2.0), we can simply use radius as corner distance\n"
"    // to compute vertex position of screen-oriented quad.\n"
"    // Compute corner vector\n"
"    vec3 corner_direction =  up * up_vector + right * right_vector;\n"
"    // Calculate vertex of screen-oriented quad (billboard)\n"
"    vec4 vertex = vec4(gl_Vertex.xyz + radius * corner_direction, 1.);\n"
"    // Calculate vertex position in modelview space\n"
"    vec4 eye_space_pos = gl_ModelViewMatrix * vertex;\n"
"    // Compute sphere position in modelview space\n"
"    vec4 tmppos = gl_ModelViewMatrix * gl_Vertex;\n"
"    sphere_center = vec3(tmppos) / tmppos.w;\n"
"    // Compute ray direction and origin point\n"
"    point = vec3(eye_space_pos) / eye_space_pos.w;\n"
"    // Pass fog coordinate\n"
"    gl_FogFragCoord = abs(sphere_center.z); \n"
"    // Pass the transformed vertex for clipping plane calculations\n"
"    gl_ClipVertex = eye_space_pos;\n"
"    vec3 eye_pos = vec3(gl_ModelViewMatrix * gl_Vertex);\n"
"    // Pass transformed vertex\n"
"    gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * vertex;\n"
"    bgTextureLookup = (gl_Position.xy/gl_Position.w) / 2.0 + 0.5;\n"
"}\n"
;
const char* cylinder_vs =
"// cylinder imposter vertex shader\n"
"attribute vec4 attr_origin;\n"
"attribute vec4 attr_axis;\n"
"attribute vec4 attr_colors;\n"
"attribute vec4 attr_colors2;\n"
"uniform float uni_radius;\n"
"//varying vec3 point; // surface point\n"
"//varying vec3 axis; // cylinder axis\n"
"//varying vec3 base; // cylinder base\n"
"//varying vec3 end; // cylinder end\n"
"//varying vec3 U; // cylinder base plane coordinates\n"
"//varying vec3 V;\n"
"//varying float radius; // radius\n"
"//varying float cap; // should we draw the endcap\n"
"//varying float inv_sqr_height;\n"
"varying vec4 packed_data_0 ;\n"
"varying vec4 packed_data_1 ;\n"
"varying vec4 packed_data_2 ;\n"
"varying vec4 packed_data_3 ;\n"
"varying vec4 packed_data_4 ;\n"
"varying vec4 packed_data_5 ;\n"
"#define point ( packed_data_0.xyz )\n"
"#define axis ( packed_data_1.xyz )\n"
"#define base ( packed_data_2.xyz )\n"
"#define end ( packed_data_3.xyz )\n"
"#define U ( packed_data_4.xyz )\n"
"#define V ( packed_data_5.xyz )\n"
"#define radius (packed_data_3.w)\n"
"#define cap (packed_data_4.w)\n"
"#define inv_sqr_height (packed_data_5.w)\n"
"varying vec4 color1;\n"
"varying vec4 color2;\n"
"varying vec2 bgTextureLookup;\n"
"uniform vec2 pixelSize;\n"
"void main(void)\n"
"{\n"
"    if (uni_radius!=0.0){\n"
"        radius = uni_radius * attr_origin.w;\n"
"    } else {\n"
"        radius = attr_origin.w;\n"
"    }\n"
"    color1 = attr_colors;\n"
"    color2 = attr_colors2;\n"
"    float packed_flags = attr_axis.w;\n"
"    vec4 flags = mod(vec4(packed_flags/262144.0, packed_flags/4096.0, \n"
"                          packed_flags/64.0, packed_flags), 64.0);\n"
"    cap = flags.x;\n"
"    float right_v = flags.y;\n"
"    float up_v = flags.z;\n"
"    float out_v = flags.w;\n"
"    // calculate reciprocal of squared height\n"
"    inv_sqr_height = length(attr_axis.xyz);\n"
"    inv_sqr_height *= inv_sqr_height;\n"
"    inv_sqr_height = 1.0 / inv_sqr_height;\n"
"    // h is a normalized cylinder axis\n"
"    vec3 h = normalize(attr_axis.xyz);\n"
"    // axis is the cylinder axis in modelview coordinates\n"
"    axis =  normalize(gl_NormalMatrix * h);\n"
"    // u, v, h is local system of coordinates\n"
"    vec3 u = cross(h, vec3(1.0, 0.0, 0.0));\n"
"    if (dot(u,u) < 0.001) \n"
"      u = cross(h, vec3(0.0, 1.0, 0.0));\n"
"    u = normalize(u);\n"
"    vec3 v = normalize(cross(u, h));\n"
"    // transform to modelview coordinates\n"
"    U = normalize(gl_NormalMatrix * u);\n"
"    V = normalize(gl_NormalMatrix * v);\n"
"    \n"
"    // compute bounding box vertex position\n"
"    vec4 vertex = vec4(attr_origin.xyz, 1.0); \n"
"    vertex.xyz += up_v * attr_axis.xyz;\n"
"    vertex.xyz += (2.0 * right_v - 1.0) * radius * u;\n"
"    vertex.xyz += (2.0 * out_v - 1.0) * radius * v;\n"
"    vertex.xyz += (2.0 * up_v - 1.0) * radius * h;\n"
"    vec4 base4 = gl_ModelViewMatrix * vec4(attr_origin.xyz, 1.0);\n"
"    base = base4.xyz / base4.w;\n"
"    vec4 end4 = gl_ModelViewMatrix * vec4(attr_origin.xyz + 1.0 * attr_axis.xyz, 1.0);\n"
"    end = end4.xyz / end4.w;\n"
"    vec4 tvertex = gl_ModelViewMatrix * vertex;\n"
"    point = tvertex.xyz / tvertex.w;\n"
"    gl_Position = gl_ModelViewProjectionMatrix * vertex;\n"
"    bgTextureLookup = (gl_Position.xy/gl_Position.w) / 2.0 + 0.5;\n"
"}\n"
;
const char* cylinder_fs =
"// cylinder imposter fragment shader\n"
"uniform bool lighting_enabled;\n"
"uniform float fog_enabled;\n"
"uniform sampler2D bgTextureMap;\n"
"uniform vec3 fogSolidColor;\n"
"uniform float fogIsSolidColor;\n"
"uniform bool bg_gradient;\n"
"uniform float inv_height;\n"
"uniform float ortho;\n"
"uniform float no_flat_caps;\n"
"uniform bool filter_front_facing;\n"
"uniform bool two_sided_lighting_enabled;\n"
"uniform int light_count;\n"
"uniform float shininess;\n"
"uniform float shininess_0;\n"
"uniform int spec_count;\n"
"uniform float spec_value;\n"
"uniform float spec_value_0;\n"
"uniform float half_bond;\n"
"#include ANAGLYPH_HEADER\n"
"//varying vec3 point; // surface point\n"
"//varying vec3 axis; // cylinder axis\n"
"//varying vec3 base; // cylinder base\n"
"//varying vec3 end; // cylinder end\n"
"//varying vec3 U; // cylinder base plane coordinates\n"
"//varying vec3 V;\n"
"//varying float radius; // radius\n"
"//varying float cap; // should we draw the endcap\n"
"//varying float inv_sqr_height;\n"
"varying vec4 packed_data_0 ;\n"
"varying vec4 packed_data_1 ;\n"
"varying vec4 packed_data_2 ;\n"
"varying vec4 packed_data_3 ;\n"
"varying vec4 packed_data_4 ;\n"
"varying vec4 packed_data_5 ;\n"
"// point -> surface_point b/c preprocessor replaces _point\n"
"#define surface_point ( packed_data_0.xyz )\n"
"#define axis ( packed_data_1.xyz )\n"
"#define base ( packed_data_2.xyz )\n"
"// end -> end_cyl\n"
"#define end_cyl packed_data_3.xyz\n"
"#define U ( packed_data_4.xyz )\n"
"#define V ( packed_data_5.xyz )\n"
"#define radius ( packed_data_3.w )\n"
"#define cap ( packed_data_4.w )\n"
"#define inv_sqr_height ( packed_data_5.w )\n"
"varying vec4 color1;\n"
"varying vec4 color2;\n"
"uniform float g_Fog_end;\n"
"uniform float g_Fog_scale;\n"
"varying vec2 bgTextureLookup;\n"
"uniform float isStretched;\n"
"uniform float isCentered;\n"
"uniform float isCenteredOrRepeated;\n"
"uniform float isTiled;\n"
"uniform vec2 tileSize;\n"
"uniform vec2 tiledSize;\n"
"uniform vec2 viewImageSize;\n"
"uniform vec2 pixelSize;\n"
"uniform vec2 halfPixel;\n"
"#include ComputeFogColor\n"
"#include ComputeColorForLight\n"
"void main(void)\n"
"{\n"
"#ifndef cylinder_shader_ff_workaround\n"
"    // cull back face - otherwise we are drawing all pixels twice\n"
"    // this change gives roughly 2x speedup\n"
"    if (filter_front_facing && !gl_FrontFacing) \n"
"      discard; \n"
"#endif\n"
"    vec3 ray_target = surface_point;\n"
"    vec3 ray_origin = vec3(0.0);\n"
"    vec3 ray_direction = mix(normalize(ray_origin - ray_target), vec3(0.0, 0.0, 1.0), ortho);\n"
"    // basis is local system of coordinates for the cylinder\n"
"    mat3 basis = mat3(U, V, axis);\n"
"    vec3 diff = ray_target - 0.5 * (base + end_cyl);\n"
"    vec3 P = diff * basis;\n"
"    // angle (cos) between cylinder cylinder_axis and ray direction\n"
"    float dz = dot(axis, ray_direction);\n"
"    float radius2 = radius*radius;\n"
"    // calculate distance to the cylinder from ray origin\n"
"    vec3 D = vec3(dot(U, ray_direction),\n"
"                  dot(V, ray_direction),\n"
"                  dz);\n"
"    float a0 = P.x*P.x + P.y*P.y - radius2;\n"
"    float a1 = P.x*D.x + P.y*D.y;\n"
"    float a2 = D.x*D.x + D.y*D.y;\n"
"    // calculate a dicriminant of the above quadratic equation\n"
"    float d = a1*a1 - a0*a2;\n"
"    if (d < 0.0)\n"
"        // outside of the cylinder\n"
"        discard;\n"
"    float dist = (-a1 + sqrt(d))/a2;\n"
"    // point of intersection on cylinder surface\n"
"    vec3 new_point = ray_target + dist * ray_direction;\n"
"    vec3 tmp_point = new_point - base;\n"
"    vec3 normal = normalize(tmp_point - axis * dot(tmp_point, axis));\n"
"    float ratio = dot(new_point-base, vec3(end_cyl-base)) * inv_sqr_height;\n"
"    ray_origin = mix(ray_origin, surface_point, ortho);\n"
"    /* cap :  4 bits : 1st - frontcap\n"
"                       2nd - endcap\n"
"                       3rd - frontcapround\n"
"                       4th - endcapround\n"
"     */\n"
"    float fcap = cap;\n"
"    float frontcap = 0.0, frontcapround = 0.0;\n"
"    float endcap = 0.0, endcapround = 0.0;\n"
"    frontcap = mod(fcap, 2.0);\n"
"    fcap = ( fcap - frontcap ) / 2.0;\n"
"    endcap = mod(fcap, 2.0);\n"
"    fcap = ( fcap - endcap ) / 2.0;\n"
"    frontcapround = floor((mod(fcap, 2.0) + no_flat_caps) / 2.0);\n"
"    fcap = ( fcap - frontcapround ) / 2.0;\n"
"    endcapround = floor((mod(fcap, 2.0) + no_flat_caps) / 2.0);\n"
"    fcap = ( fcap - endcapround ) / 2.0;\n"
"    \n"
"    vec4 color;\n"
"    float dp = clamp(-half_bond*new_point.z*inv_height, 0., .5);\n"
"    color = mix(color1, color2, smoothstep(.5 - dp, .5 + dp, ratio));\n"
"    // test front cap\n"
"    float cap_test = dot((new_point - base), axis);\n"
"    // to calculate caps, simply check the angle between\n"
"    // the point of intersection - cylinder end vector\n"
"    // and a cap plane normal (which is the cylinder cylinder_axis)\n"
"    // if the angle < 0, the point is outside of cylinder\n"
"    // test front cap\n"
"    // flat\n"
"    if (frontcapround < 0.5 && cap_test < 0.0) {\n"
"      // ray-plane intersection\n"
"      color = color1;\n"
"      float dNV = dot(-axis, ray_direction);\n"
"      if (dNV < 0.0) discard;\n"
"      float near = dot(-axis, (base)) / dNV;\n"
"      new_point = ray_direction * near + ray_origin;\n"
"      // within the cap radius?\n"
"      if (dot(new_point - base, new_point-base) > radius2) discard;\n"
"      normal = -axis;\n"
"    }\n"
"    // round\n"
"    if (frontcapround > 0.5 && cap_test < 0.0) {\n"
"      if ( frontcap < 0.5)\n"
"        discard;\n"
"      color = color1;\n"
"      vec3 sphere_direction = mix(base, ray_origin - base, ortho);\n"
"      float b = dot(sphere_direction, ray_direction);\n"
"      float pos = b*b + radius2 -dot(sphere_direction, sphere_direction);\n"
"      if ( pos < 0.0)\n"
"        discard;\n"
"      float near = mix(b + sqrt(pos), sqrt(pos) - b, ortho);\n"
"      new_point = near * ray_direction + ray_origin;     \n"
"      normal = normalize( new_point - base ); \n"
"    }\n"
"    // test end cap\n"
"    cap_test = dot((new_point - end_cyl), axis);\n"
"    // flat\n"
"    if (endcapround < 0.5 && cap_test > 0.0) {\n"
"      // ray-plane intersection\n"
"      color = color2;\n"
"      float dNV = dot(axis, ray_direction);\n"
"      if (dNV < 0.0) discard;\n"
"      float near = dot(axis, end_cyl) / dNV;\n"
"      new_point = ray_direction * near + ray_origin;\n"
"      // within the cap radius?\n"
"      if (dot(new_point - end_cyl, new_point-base) > radius2) discard;\n"
"      normal = axis;\n"
"    }\n"
"    // round\n"
"    if (endcapround > 0.5 && cap_test > 0.0) {\n"
"      if ( endcap < 0.5)\n"
"        discard;\n"
"      color = color2;\n"
"      vec3 sphere_direction = mix(end_cyl, ray_origin - end_cyl, ortho);\n"
"      float b = dot(sphere_direction, ray_direction);\n"
"      float pos = b*b + radius2 -dot(sphere_direction, sphere_direction);\n"
"      if ( pos < 0.0)\n"
"        discard;\n"
"      float near = mix(b + sqrt(pos), sqrt(pos) - b, ortho);\n"
"      new_point = near * ray_direction + ray_origin;\n"
"      normal = normalize( new_point - end_cyl );\n"
"    }\n"
"    vec2 clipZW = new_point.z * gl_ProjectionMatrix[2].zw +\n"
"        gl_ProjectionMatrix[3].zw;\n"
"    float depth = 0.5 + 0.5 * clipZW.x / clipZW.y;\n"
"    // this is a workaround necessary for Mac\n"
"    // otherwise the modified fragment won't clip properly\n"
"    if (depth <= 0.0)\n"
"      discard;\n"
"    if (depth >= 1.0)\n"
"      discard;\n"
"    gl_FragDepth = depth;\n"
"  vec4 final_color;\n"
"  int i;\n"
"  float NdotL, NdotH;\n"
"  final_color = (gl_LightModel.ambient) * color;\n"
"#include CallComputeColorForLight\n"
"  float cfog = clamp((g_Fog_end + new_point.z) * g_Fog_scale, 0.0, 1.0);\n"
"  cfog = mix(1.0, clamp(cfog, 0.0, 1.0), fog_enabled);\n"
"  vec4 fogColor = ComputeFogColor();\n"
"  final_color.rgb = mix(fogColor.xyz, final_color.rgb, cfog);\n"
"  vec4 fColor = vec4(final_color.rgb, color.a);\n"
"#include ANAGLYPH_BODY\n"
"}\n"
;
const char* sphere_arb_vs =
"!!ARBvp1.0\n"
"# input contains the sphere radius in model coordinates\n"
"PARAM sphereRadius = program.env[0];\n"
"PARAM half = {0.5, 0.5, 0.0, 2.0 };\n"
"PARAM zero = {0.0, 0.0, 0.0, 1.0 };\n"
"ATTRIB vertexPosition  = vertex.position;\n"
"ATTRIB vertexNormal    = vertex.normal;\n"
"ATTRIB textureCoord    = vertex.texcoord;\n"
"OUTPUT outputPosition  = result.position;\n"
"TEMP   pos, rad, shf, txt, tip;\n"
"# Transform the vertex by the modelview matrix to get into the frame of the camera\n"
"DP4    pos.x, state.matrix.modelview.row[0], vertexPosition;\n"
"DP4    pos.y, state.matrix.modelview.row[1], vertexPosition;\n"
"DP4    pos.z, state.matrix.modelview.row[2], vertexPosition;\n"
"DP4    pos.w, state.matrix.modelview.row[3], vertexPosition;\n"
"# copy current texture coords\n"
"MOV    txt.xyzw, textureCoord.xyzw;\n"
"# scale the radius by a factor of two\n"
"MUL    rad.xy, 2.0, sphereRadius.z;\n"
"# shift the texture coordinates to the origin\n"
"SUB    shf.xy, textureCoord, {0.5, 0.5, 0.0, 0.0};\n"
"# multiply them to get the vertex offset\n"
"MUL    shf.xy, rad, shf;\n"
"# define the new vertex for corner of sphere\n"
"ADD    pos.xy, pos, shf;\n"
"# apply the projection matrix to get clip coordinates \n"
"DP4    outputPosition.x, state.matrix.projection.row[0], pos;\n"
"DP4    outputPosition.y, state.matrix.projection.row[1], pos;\n"
"DP4    shf.z, state.matrix.projection.row[2], pos;\n"
"DP4    shf.w, state.matrix.projection.row[3], pos;\n"
"MOV    outputPosition.zw, shf;\n"
"# compute camera position for front tip of the sphere\n"
"ADD    pos.z, pos.z, sphereRadius;\n"
"# compute Zc and Wc for front tip of the sphere\n"
"DP4    tip.z, state.matrix.projection.row[2], pos;\n"
"DP4    tip.w, state.matrix.projection.row[3], pos;\n"
"# compute 1/Wc for sphere tip \n"
"RCP    rad.z, tip.w;\n"
"# put sphere center Zc into tip.w \n"
"MOV    tip.w, shf.z;\n"
"# compute 1/Wc for sphere center \n"
"RCP    rad.w, shf.w;\n"
"# compute Z/Wc for both sphere tip (->txt.z) and center (->txt.w) \n"
"MUL    txt.zw, tip, rad;\n"
"# move into range 0.0-1.0 to get the normalized depth coordinate (0.5*(Zc/Wc)+0.5) \n"
"ADD    txt.zw, {0.0,0.0,1.0,1.0}, txt;\n"
"MUL    txt.zw, {0.0,0.0,0.5,0.5}, txt;\n"
"# Pass the color through\n"
"MOV    result.color, vertex.color;\n"
"# Pass texture through\n"
"MOV    result.texcoord, txt;\n"
"END\n"
;
const char* sphere_arb_fs =
"!!ARBfp1.0\n"
"PARAM fogInfo = program.env[0];\n"
"PARAM fogColor = state.fog.color;\n"
"ATTRIB fogCoord = fragment.fogcoord;\n"
"TEMP pln, norm, depth, color, light, spec, fogFactor;\n"
"# fully clip spheres that hit the camera\n"
"KIL fragment.texcoord.z;\n"
"# move texture coordinates to origin\n"
"MOV norm.z, 0;\n"
"SUB norm.xy, fragment.texcoord, {0.5,0.5,0.0,0.0};\n"
"# compute x^2 + y^2, if > 0.25 then kill the pixel -- not in sphere\n"
"# kill pixels that aren't in the center circle\n"
"DP3 pln.z, norm, norm;\n"
"SUB pln.z, 0.25, pln.z;\n"
"KIL pln.z;\n"
"# build a complete unit normal\n"
"MUL pln.z, 4.0, pln.z;\n"
"RSQ pln.z, pln.z;\n"
"MUL norm.xy, 2.0, norm;\n"
"RCP norm.z, pln.z;\n"
"# interpolate the Zndc coordinate on the sphere \n"
"LRP depth.z, norm.z, fragment.texcoord.z, fragment.texcoord.w;\n"
"MOV result.depth.z, depth.z;\n"
"# light0\n"
"DP3 light, state.light[1].half, norm;\n"
"MOV light.w, 60.0;\n"
"LIT light, light;\n"
"# ambient\n"
"MOV color.xyzw, {0.06,0.06,0.06,1.0};\n"
"ADD color.xyz, light.y, 0.1;\n"
"MUL color.xyz, fragment.color, color;\n"
"MUL spec.xyz, light.z, 0.5;\n"
"ADD color.xyz, color,spec;\n"
"# apply fog using linear interp over Zndc\n"
"MAX fogFactor.x, depth.z, fogInfo.x;\n"
"SUB fogFactor.x, fogFactor.x, fogInfo.x;\n"
"MUL fogFactor.x, fogFactor.x, fogInfo.y;\n"
"LRP color.xyz, fogFactor.x, fogColor, color;\n"
"MOV result.color, color;\n"
"END\n"
;
const char* indicator_vs =
"#ifdef PYMOL_IOS\n"
"precision highp float;\n"
"#else\n"
"#version 120\n"
"#endif\n"
"attribute vec4 a_Vertex;\n"
"attribute vec4 a_Color;\n"
"varying vec4 COLOR;\n"
"#ifdef PYMOL_IOS\n"
"uniform mat4 g_ModelViewMatrix;\n"
"uniform mat4 g_ProjectionMatrix;\n"
"#endif\n"
"uniform float g_pointSize;\n"
"void main()\n"
"{\n"
"  COLOR = a_Color;\n"
"  gl_PointSize = g_pointSize;\n"
"#ifdef PYMOL_IOS\n"
"  gl_Position = g_ProjectionMatrix * g_ModelViewMatrix * a_Vertex;\n"
"#else\n"
"  gl_Position = gl_ModelViewProjectionMatrix * a_Vertex;\n"
"#endif\n"
"}\n"
;
const char* indicator_fs =
"#ifdef PYMOL_IOS\n"
"precision mediump float;\n"
"#else\n"
"#version 120\n"
"#endif\n"
"uniform sampler2D textureMap;\n"
"uniform vec2 textureLookup ;\n"
"uniform vec2 textureScale ;\n"
"#include ANAGLYPH_HEADER\n"
"void main()\n"
"{\n"
"  vec4 fColor = texture2D(textureMap, textureLookup + gl_PointCoord * textureScale);\n"
"#include ANAGLYPH_BODY\n"
"}\n"
;
const char* compute_color_for_light_fs =
"#ifdef default\n"
"vec4 ComputeColorForLight(bool is_interior,\n"
"                          vec3 L, vec3 H, vec4 ambient, vec4 diffuse, float spec, float shine){\n"
"#endif\n"
"#ifdef sphere\n"
"vec4 ComputeColorForLight(vec3 NORMAL, vec3 L, vec3 H, vec4 ambient, vec4 diffuse, float spec, float shine){\n"
"#endif\n"
"#ifdef cylinder\n"
"vec4 ComputeColorForLight(vec3 NORMAL, vec3 L, vec3 H, vec4 ambient, vec4 diffuse, float spec, float shine, vec4 COLOR){\n"
"#endif\n"
"  float NdotL, NdotH;\n"
"  vec4 ret_val = vec4(0.);\n"
"#ifdef default\n"
"  if (!is_interior){\n"
"#endif\n"
"    ret_val += ambient * COLOR;\n"
"    NdotL = dot(NORMAL, L);\n"
"    if (NdotL > 0.0) {\n"
"       ret_val += diffuse * NdotL * COLOR;\n"
"       NdotH = max(dot(NORMAL, H), 0.0);\n"
"       ret_val += spec * pow(NdotH, shine);\n"
"    }\n"
"#ifdef default\n"
"  }\n"
"  if (two_sided_lighting_enabled && is_interior){\n"
"    NdotL = dot(-NORMAL, L);\n"
"    if (NdotL > 0.0) {\n"
"       ret_val += diffuse * NdotL * COLOR;\n"
"       NdotH = max(dot(-NORMAL, H), 0.0);\n"
"       ret_val += spec * pow(NdotH, shine);\n"
"    }\n"
"  }\n"
"#endif\n"
"  return ret_val;\n"
"}\n"
;
const char* call_compute_color_for_light_fs =
"// if light is 0, postfix = _0, otherwise blank\n"
"#ifdef sphere\n"
"    final_color += ComputeColorForLight(N, normalize(vec3(gl_LightSource[`light`].position)),\n"
"                                        normalize(vec3(gl_LightSource[`light`].halfVector.xyz)),\n"
"                                        gl_LightSource[`light`].ambient,\n"
"                                        gl_LightSource[`light`].diffuse,\n"
"                                        spec_value`postfix`, shininess`postfix`);\n"
"#endif\n"
"#ifdef default\n"
"    final_color += ComputeColorForLight(is_interior,\n"
"                                        normalize(vec3(gl_LightSource[`light`].position)),\n"
"                                        normalize(vec3(gl_LightSource[`light`].halfVector.xyz)),\n"
"                                        gl_LightSource[`light`].ambient,\n"
"                                        gl_LightSource[`light`].diffuse,\n"
"                                        spec_value`postfix`, shininess`postfix`);\n"
"#endif\n"
"#ifdef cylinder\n"
"    final_color += ComputeColorForLight(normal, normalize(vec3(gl_LightSource[`light`].position)),\n"
"                                        normalize(vec3(gl_LightSource[`light`].halfVector.xyz)),\n"
"                                        gl_LightSource[`light`].ambient,\n"
"                                        gl_LightSource[`light`].diffuse,\n"
"                                        spec_value`postfix`, shininess`postfix`, color);\n"
"#endif\n"
;
const char* compute_fog_color_fs =
"vec4 ComputeFogColor(){\n"
"#ifdef bg_image_mode_stretched\n"
"  vec2 bgLookup = pixelSize * floor(bgTextureLookup / pixelSize);\n"
"  vec4 bgColor = texture2D(bgTextureMap, bgLookup);\n"
"  return vec4(bgColor.rgb*bgColor.a + (1.-bgColor.a) * fogSolidColor.rgb, 1.);\n"
"#endif\n"
"#ifdef bg_image_mode_solid\n"
"  return vec4(fogSolidColor.rgb, 1.);	\n"
"#endif\n"
"}\n"
;
const char* bg_vs =
"attribute vec3 a_Vertex;\n"
"varying vec2 bgTextureLookup ;\n"
"uniform float isCentered;\n"
"uniform vec2 imageSize;\n"
"uniform vec2 screenCenter;\n"
"uniform vec2 pixelSize;\n"
"void main()\n"
"{\n"
"  vec2 imageVertex = a_Vertex.xy;\n"
"  imageVertex = pixelSize * floor(imageVertex / pixelSize);\n"
"  gl_Position = vec4(imageVertex.x, imageVertex.y, .5, 1.);\n"
"  bgTextureLookup = (1. + a_Vertex.xy) / 2.;\n"
"  bgTextureLookup = pixelSize * floor(bgTextureLookup / pixelSize);\n"
"}\n"
;
const char* bg_fs =
"uniform sampler2D bgTextureMap;\n"
"varying vec2 bgTextureLookup ;\n"
"uniform vec3 fogSolidColor;\n"
"uniform float fogIsSolidColor;\n"
"uniform vec2 viewImageSize;\n"
"uniform vec2 pixelSize;\n"
"uniform vec2 halfPixel;\n"
"void main()\n"
"{\n"
"#ifdef bg_image_mode_stretched\n"
"  vec2 bgLookup = pixelSize * floor(bgTextureLookup / pixelSize);\n"
"  vec4 bgColor = texture2D(bgTextureMap, bgLookup);\n"
"  gl_FragColor = vec4(bgColor.rgb*bgColor.a + (1.-bgColor.a) * fogSolidColor.rgb, 1.);\n"
"#endif\n"
"#ifdef bg_image_mode_solid\n"
"  gl_FragColor = vec4(fogSolidColor.rgb, 1.);\n"
"#endif\n"
"}\n"
;
const char* label_vs =
"attribute vec4 attr_worldpos;\n"
"attribute vec3 attr_screenoffset;\n"
"attribute vec2 attr_texcoords;\n"
"attribute vec3 attr_screenworldoffset;\n"
"attribute vec4 attr_t_pickcolor; // changed name for ATI, optional attribute\n"
"                                 // cannot be first/0 index, ATI sets index\n"
"                                 // alphabetically\n"
"varying vec2 textureLookup ;\n"
"varying vec3 normalizedViewCoordinate;\n"
"varying vec4 pickcolor ;\n"
"uniform vec2 screenSize;\n"
"uniform vec2 pixelSize;\n"
"uniform float aspectRatioAdjustment;\n"
"uniform float screenOriginVertexScale;\n"
"varying float fog;\n"
"uniform float fog_enabled; // actually bool\n"
"void main()\n"
"{\n"
"  vec4 pos = gl_ModelViewProjectionMatrix * attr_worldpos;\n"
"  pos /= pos.w;\n"
"  pos.xy += attr_screenworldoffset.xy / (screenSize.xy * screenOriginVertexScale);\n"
"  pos.xy += attr_screenoffset.xy * 2. / screenSize * vec2(aspectRatioAdjustment, 1.);\n"
"  // rounding to nearest pixel\n"
"  pos.xy = (pixelSize * floor((pos.xy + 1.) / pixelSize)) - 1.;\n"
"  vec3 viewVector = vec3(gl_ModelViewMatrixTranspose * vec4(0.,0., -1.,0.));\n"
"  vec4 a_center = (attr_worldpos + attr_screenworldoffset.z * vec4(viewVector, 0.));\n"
"  vec4 transformedPositionZ = gl_ModelViewProjectionMatrix * a_center;\n"
"  pos.z = transformedPositionZ.z / transformedPositionZ.w;\n"
"  gl_Position = pos;\n"
"  textureLookup = attr_texcoords;\n"
"  normalizedViewCoordinate = pos.xyz / 2.0 + 0.5;\n"
"  if (fog_enabled > 0.5) {\n"
"    vec3 eye_pos = vec3(gl_ModelViewMatrix * attr_worldpos);\n"
"    fog = max(0.0, (gl_Fog.end - abs(eye_pos.z)) * gl_Fog.scale);\n"
"  } else {\n"
"    fog = 1.1; // >= 1.0\n"
"  }\n"
"  pickcolor = attr_t_pickcolor;\n"
"}\n"
;
const char* label_fs =
"/* ios recent */\n"
"uniform sampler2D textureMap;\n"
"varying vec2 textureLookup ;\n"
"varying vec4 pickcolor ;\n"
"uniform float isPicking;\n"
"uniform sampler2D bgTextureMap;\n"
"uniform vec3 fogSolidColor;\n"
"uniform float fogIsSolidColor;\n"
"varying float fog;\n"
"varying vec3 normalizedViewCoordinate;\n"
"#define bgTextureLookup normalizedViewCoordinate.xy\n"
"uniform float isStretched;\n"
"uniform float isCentered;\n"
"uniform float isCenteredOrRepeated;\n"
"uniform float isTiled;\n"
"uniform vec2 tileSize;\n"
"uniform vec2 tiledSize;\n"
"uniform vec2 viewImageSize;\n"
"uniform vec2 pixelSize;\n"
"uniform vec2 halfPixel;\n"
"#include ComputeFogColor\n"
"void main()\n"
"{\n"
"  vec4 fColor = texture2D(textureMap, textureLookup);\n"
"  if (fog < 1.0) {\n"
"      vec4 fogColor = ComputeFogColor();\n"
"      fColor.rgb = mix(fogColor.rgb, fColor.rgb, fog);\n"
"  }\n"
"#ifdef PYMOL_IOS\n"
"  vec4 npColor = (1. - isPicking) * fColor;\n"
"  if (npColor.a < .1)\n"
"     discard;\n"
"  gl_FragColor = npColor + isPicking * pickcolor;\n"
"#else\n"
"  gl_FragColor = (1. - isPicking) * fColor + isPicking * pickcolor;\n"
"#endif\n"
"}\n"
;
const char* screen_vs =
"attribute vec3 attr_screenoffset;\n"
"attribute vec2 attr_texcoords;\n"
"attribute vec4 attr_backgroundcolor;\n"
"varying vec2 textureLookup ;\n"
"varying vec4 backgroundColor;\n"
"uniform vec2 t2PixelSize;\n"
"void main()\n"
"{\n"
"  vec4 transformedPosition = vec4(attr_screenoffset.x * t2PixelSize.x - 1.,\n"
"                                  attr_screenoffset.y * t2PixelSize.y - 1.,\n"
"                                  .9, 1.);\n"
"  gl_Position = transformedPosition;\n"
"  backgroundColor = attr_backgroundcolor;\n"
"  textureLookup = attr_texcoords;\n"
"}\n"
;
const char* screen_fs =
"/* ios recent */\n"
"uniform sampler2D textureMap;\n"
"varying vec4 backgroundColor;\n"
"varying vec2 textureLookup ;\n"
"#include ANAGLYPH_HEADER\n"
"void main()\n"
"{\n"
"  vec4 fColor = texture2D(textureMap, textureLookup);\n"
"#ifdef PYMOL_IOS\n"
"  if (isLabel > .5 && fColor.a < .1)\n"
"     discard;\n"
"#endif\n"
"  vec4 bColor = backgroundColor * (1.-fColor.a);\n"
"  fColor = vec4(bColor.rgb + fColor.rgb * fColor.a, bColor.a + fColor.a );\n"
"#include ANAGLYPH_BODY\n"
"}\n"
;
const char* labelscreen_vs =
"attribute vec3 attr_screenoffset;\n"
"attribute vec2 attr_texcoords;\n"
"varying vec2 textureLookup ;\n"
"uniform vec2 t2PixelSize;\n"
"void main()\n"
"{\n"
"  vec4 transformedPosition = vec4(attr_screenoffset.x * t2PixelSize.x - 1.,\n"
"                                  attr_screenoffset.y * t2PixelSize.y - 1.,\n"
"                                  .9, 1.);\n"
"  gl_Position = transformedPosition;\n"
"  textureLookup = attr_texcoords;\n"
"}\n"
;
const char* labelscreen_fs =
"/* ios recent */\n"
"uniform sampler2D textureMap;\n"
"varying vec2 textureLookup ;\n"
"void main()\n"
"{\n"
"  vec4 fColor = texture2D(textureMap, textureLookup);\n"
"#ifdef PYMOL_IOS\n"
"  if (fColor.a < .1)\n"
"     discard;\n"
"#endif\n"
"  gl_FragColor = fColor;\n"
"}\n"
;
const char* defaultscreen_vs =
"attribute vec4 a_Vertex;\n"
"attribute vec4 a_Color;\n"
"varying vec4 COLOR ;\n"
"uniform vec2 t2PixelSize;\n"
"void main()\n"
"{\n"
"  COLOR = a_Color;\n"
"  \n"
"  gl_Position = vec4(a_Vertex.x * t2PixelSize.x - 1., a_Vertex.y * t2PixelSize.y - 1., .5, 1.);\n"
"}\n"
;
const char* defaultscreen_fs =
"varying vec4 COLOR ;\n"
"#include ANAGLYPH_HEADER\n"
"void main()\n"
"{\n"
"  vec4 fColor = COLOR;\n"
"#include ANAGLYPH_BODY\n"
"}\n"
;
const char* anaglyph_fs =
"#ifdef ANAGLYPH\n"
"  fColor.rgb = matL * pow(fColor.rgb, vec3(gamma));\n"
"#endif\n"
"gl_FragColor = fColor;\n"
;
const char* anaglyph_header_fs =
"#ifdef ANAGLYPH\n"
"uniform mat3 matL;\n"
"uniform float gamma;\n"
"#endif\n"
;
const char* ramp_vs =
"attribute vec4 a_Vertex;\n"
"attribute vec4 a_Color;\n"
"attribute vec3 a_Normal;\n"
"varying vec4 COLOR ;\n"
"varying vec3 NORMAL ;\n"
"uniform vec2 t2PixelSize;\n"
"uniform vec3 offsetPt;\n"
"void main()\n"
"{\n"
"  COLOR = a_Color;\n"
"  NORMAL = a_Normal;\n"
"  vec4 vertex = a_Vertex + vec4(offsetPt,0.);\n"
"  gl_Position = gl_ModelViewProjectionMatrix * vertex;\n"
"}\n"
;
const char* ramp_fs =
"varying vec4 COLOR ;\n"
"varying vec3 NORMAL ;\n"
"#include ANAGLYPH_HEADER\n"
"void main()\n"
"{\n"
"  float NdotV = dot(NORMAL, vec3(0.,0.,1.));\n"
"  vec4 fColor = vec4(NdotV * COLOR.xyz, COLOR.a);\n"
"//  vec4 fColor = NdotV * COLOR; // slightly transparent based on normal\n"
"//  vec4 fColor = vec4(NdotV * COLOR.rgb, (.5 + (.5 * NdotV)) * COLOR.a); // a little less transparent\n"
"#include ANAGLYPH_BODY\n"
"}\n"
;
#ifdef __cplusplus
}
#endif
